# 第一个Go程序

## hello world

```go
package main  // 声明 main 包，表明当前是一个可执行程序

import "fmt"  // 导入内置 fmt 包

func main(){  // main函数，是程序执行的入口
    fmt.Println("Hello World!")  // 在终端打印 Hello World!
}
```

## go build

- `go build`表示将源代码编译成可执行文件。
- 在hello目录下执行：
- `go build`
- 或者在其他目录执行以下命令：
- `go build hello`
- go编译器会去`GOPATH`的src目录下查找你要编译的hello项目
- 编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是windows平台会在当前目录下找到hello.exe可执行文件。
- 可在终端直接执行该hello.exe文件：
- `c:\desktop\hello>hello.exe`
- `Hello World!`
- 我们还可以使用-o参数来指定编译后得到的可执行文件的名字。
- `go build -o heiheihei.exe`

### 难题

- go build报错cannot find main module; see 'go help modules'

- 在学习golang的过程中，在$GOPATH/src/github.com/xxx/hello目录下执行go build和go test都会报下面的错误
- `go: cannot find main module; see 'go help modules'`

- **解决方案：**
- 由于之前设置过GO111MODULE=on，所以使用下面的命令解决
- `$ go mod init hello`
- 生成了一个go.mod文件，然后再执行go build成功

- **原因：**
- 之前为了提高依赖包的下载速度，使用了goproxy,然后开启的时候使用了以下命令
- `$ go env -w GO111MODULE=on`
- `$ go env -w GOPROXY=https://goproxy.cn,direct`
- 这使得go默认管理依赖的方式变成了go module模式，即依赖一个go.mod文件，其中描述了项目依赖的包和版本（类似于npm package.json，maven的pom.xml）
- 而目录中没有go.mod文件，所以go不知道主模块是什么，所以无法编译

- **使用Go Modules还是GOPATH**
- go使用一个环境变量GO111MODULE来决定使用Go Modules还是GOPATH，该变量有三个值，并在不同版本下有不同的语义

| 值 | 1.11&1.12 | 1.13 |
| :----: | :----: | :----: |
| GO111MODULE = on | 不管在GOPATH 中还是外，都强制使用go.mod | 不管在GOPATH 中还是外，都强制使用go.mod |
| GO111MODULE = off | 强制 Go 表现出 GOPATH 方式，即使在 GOPATH 之外 | 强制 Go 表现出 GOPATH 方式，即使在 GOPATH 之外 |
| GO111MODULE = auto | 在GOPATH外时，GO111MODULE = on，在GOPATH内时，GO111MODULE = off | 当有go.mod或者在GOPATH 之外GO111MODULE = on，当处于 GOPATH 内且没有 go.mod 文件时，GO111MODULE = off |
