# 第一个Go程序

## hello world

```go
package main  // 声明 main 包，表明当前是一个可执行程序

import "fmt"  // 导入内置 fmt 包

func main(){  // main函数，是程序执行的入口
    fmt.Println("Hello World!")  // 在终端打印 Hello World!
}
```

### 难题

- go build报错cannot find main module; see 'go help modules'

- 在学习golang的过程中，在$GOPATH/src/github.com/xxx/hello目录下执行go build和go test都会报下面的错误
- go: cannot find main module; see 'go help modules'

- 解决方案：
- 由于之前设置过GO111MODULE=on，所以使用下面的命令解决
- $ go mod init hello
- 生成了一个go.mod文件，然后再执行go build成功

- 原因：
- 之前为了提高依赖包的下载速度，使用了goproxy,然后开启的时候使用了以下命令
- $ go env -w GO111MODULE=on
- $ go env -w GOPROXY=https://goproxy.cn,direct
- 这使得go默认管理依赖的方式变成了go module模式，即依赖一个go.mod文件，其中描述了项目依赖的包和版本（类似于npm package.json，maven的pom.xml）
- 而目录中没有go.mod文件，所以go不知道主模块是什么，所以无法编译

- 使用Go Modules还是GOPATH
- go使用一个环境变量GO111MODULE来决定使用Go Modules还是GOPATH，该变量有三个值，并在不同版本下有不同的语义

| 值 | 1.11&1.12 | 1.13 |
| :----: | :----: | :----: |
| GO111MODULE = on | 不管在GOPATH 中还是外，都强制使用go.mod | 不管在GOPATH 中还是外，都强制使用go.mod |
| GO111MODULE = off | 强制 Go 表现出 GOPATH 方式，即使在 GOPATH 之外 | 强制 Go 表现出 GOPATH 方式，即使在 GOPATH 之外 |
| GO111MODULE = auto | 在GOPATH外时，GO111MODULE = on，在GOPATH内时，GO111MODULE = off | 当有go.mod或者在GOPATH 之外GO111MODULE = on，当处于 GOPATH 内且没有 go.mod 文件时，GO111MODULE = off |
